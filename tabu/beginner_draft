import random

class TabuSearchScheduler:
    def __init__(self, jobs, machines, tabu_list_length=10, max_iterations=100):
        """
        Инициализация алгоритма
        :param jobs: список работ (job) с операциями [(машина, время), ...]
        :param machines: количество машин
        :param tabu_list_length: длина табу-списка
        :param max_iterations: максимальное количество итераций
        """
        self.jobs = jobs
        self.num_jobs = len(jobs)
        self.num_machines = machines
        self.tabu_list_length = tabu_list_length
        self.max_iterations = max_iterations
        self.tabu_list = []
        self.best_solution = None
        self.best_cost = float('inf')

    def _evaluate_solution(self, solution):
        """
        Оценка решения (makespan)
        :param solution: текущее расписание
        :return: значение функции стоимости
        """
        machine_times = [0] * self.num_machines
        job_times = [0] * self.num_jobs

        for job, op in solution:
            machine, time = self.jobs[job][op]
            start_time = max(machine_times[machine], job_times[job])
            finish_time = start_time + time
            machine_times[machine] = finish_time
            job_times[job] = finish_time

        return max(machine_times)

    def _generate_neighbors(self, solution):
        """
        Генерация соседей текущего решения
        :param solution: текущее решение
        :return: список соседей
        """
        neighbors = []
        for i in range(len(solution)):
            for j in range(i + 1, len(solution)):
                # Создаем новое соседнее решение путем обмена операций
                neighbor = solution[:]
                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
                neighbors.append(neighbor)
        return neighbors

    def _is_tabu(self, move):
        """
        Проверка, находится ли перемещение в табу-списке
        :param move: перемещение
        :return: True, если в табу-списке, иначе False
        """
        return move in self.tabu_list

    def _update_tabu_list(self, move):
        """
        Обновление табу-списка
        :param move: перемещение
        """
        self.tabu_list.append(move)
        if len(self.tabu_list) > self.tabu_list_length:
            self.tabu_list.pop(0)

    def _generate_initial_solution(self):
        """
        Генерация начального решения методом Bidir
        """
        L = [0]  # Операции, запланированные с начала
        R = [len(self.jobs) * len(self.jobs[0])]  # Операции, запланированные с конца
        S = set((j, 0) for j in range(self.num_jobs))  # Начальные операции
        T = set((j, len(self.jobs[j]) - 1) for j in range(self.num_jobs))  # Конечные операции
        solution = []  # Финальное расписание

        while S or T:
            # Выбираем и планируем операцию из S
            if S:
                next_op = min(S, key=lambda op: self.jobs[op[0]][op[1]][1])  # Выбираем по минимальному времени выполнения
                solution.append(next_op)
                S.remove(next_op)
                if next_op[1] + 1 < len(self.jobs[next_op[0]]):
                    S.add((next_op[0], next_op[1] + 1))

            # Выбираем и планируем операцию из T
            if T:
                next_op = min(T, key=lambda op: self.jobs[op[0]][op[1]][1])
                solution.append(next_op)
                T.remove(next_op)
                if next_op[1] > 0:
                    T.add((next_op[0], next_op[1] - 1))

        return solution

    def solve(self):
        """
        Запуск алгоритма Tabu Search
        :return: лучшее найденное решение и его стоимость
        """
        # Генерация начального решения
        initial_solution = self._generate_initial_solution()
        current_solution = initial_solution
        current_cost = self._evaluate_solution(current_solution)

        self.best_solution = current_solution
        self.best_cost = current_cost

        for iteration in range(self.max_iterations):
            neighbors = self._generate_neighbors(current_solution)
            best_neighbor = None
            best_neighbor_cost = float('inf')

            for neighbor in neighbors:
                cost = self._evaluate_solution(neighbor)
                move = (current_solution, neighbor)
                if cost < best_neighbor_cost and (not self._is_tabu(move) or cost < self.best_cost):
                    best_neighbor = neighbor
                    best_neighbor_cost = cost

            if best_neighbor:
                current_solution = best_neighbor
                current_cost = best_neighbor_cost

                # Обновляем лучшее решение
                if current_cost < self.best_cost:
                    self.best_solution = current_solution
                    self.best_cost = current_cost

                # Обновляем табу-список
                self._update_tabu_list((current_solution, best_neighbor))

            print(f"Iteration {iteration + 1}: Current Cost = {current_cost}, Best Cost = {self.best_cost}")

        return self.best_solution, self.best_cost


# Пример задачи
jobs = [
    [(0, 3), (1, 2), (2, 2)],  # Job 1
    [(0, 2), (2, 1), (1, 4)],  # Job 2
    [(1, 4), (0, 3)],           # Job 3
    [(3, 6), (0, 3), (1, 4)]    #J4
]
machines = 4

# Запуск Tabu Search
scheduler = TabuSearchScheduler(jobs, machines)
best_solution, best_cost = scheduler.solve()

print("Лучшее решение:", best_solution)
print("Лучшее время выполнения (makespan):", best_cost)
